package simpledb;
import java.util.*;

/**
 * Implements EQUALS join with hash join algorithm.
 */
public class JoinEquals extends AbstractDbIterator {

    private static final int CACHE_SIZE = 4 * 1024 * 1024;    // uses that much cache for hash-join algorithm

    private JoinPredicate       mPredicate;
    private JoinChild           mChild1;
    private JoinChild           mChild2;
    private JoinChild           mChildR;        // child with smaller tuple size
    private JoinChild           mChildS;        // the other child, with bigger tuple size
    private Map<Field, List<Tuple>>   mCache;   // tuples of child_r readed in batch into cache
    private Deque<Tuple>        mStack;         // currently matched tuples of child_r
    private Tuple               mTupleS;        // currently matched tuple of child_s

    /**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public JoinEquals(JoinPredicate p, DbIterator child1, DbIterator child2) {
        mPredicate  = p;
        mChild1 = new JoinChild(child1, p._fid1);
        mChild2 = new JoinChild(child2, p._fid2);
        JoinChild[] children = sortChildrenBySize(mChild1, mChild2);
        mChildR = children[0];
        mChildS = children[1];
        mCache = new HashMap<Field, List<Tuple>>();
        mStack = new ArrayDeque<Tuple>();
    }

    private class JoinChild implements DbIterator {
        DbIterator  it;
        int         field;

        public JoinChild(DbIterator c, int f) {
            it      = c;
            field   = f;
        }

        public boolean hasNext() throws DbException, TransactionAbortedException {
            return it.hasNext();
        }
        public Tuple next() throws DbException, TransactionAbortedException {
            return it.next();
        }
        public TupleDesc getTupleDesc() { return it.getTupleDesc(); }
        public void open() throws DbException, NoSuchElementException, TransactionAbortedException {
            it.open();
        }
        public void close() { it.close(); }
        public void rewind() throws DbException, TransactionAbortedException {
            it.rewind();
        }
    }

    /**
     * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() {
        return TupleDesc.combine(mChild1.getTupleDesc(), mChild2.getTupleDesc());
    }

    public void open()
        throws DbException, NoSuchElementException, TransactionAbortedException {
        mChildR.open();
        mChildS.open();
    }

    public void close() {
        mChildR.close();
        mChildS.close();
        mCache.clear();
    }

    public void rewind() throws DbException, TransactionAbortedException {
        mChildR.rewind();
        mChildS.rewind();
        mCache.clear();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, if an equality predicate is used 
     * there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException {

        if (mCache.size() == 0 )
            fillCache();

        if (!mStack.isEmpty()) {
            return concatTuples(mStack.removeFirst(), mTupleS);
        }

        while (mCache.size() > 0) {
            while (mChildS.hasNext()) {
                mTupleS = mChildS.next();
                Field field_s = mTupleS.getField(mChildS.field);
                if (mCache.containsKey(field_s))
                    mStack.addAll(mCache.get(field_s));
                if (!mStack.isEmpty()) {
                    return concatTuples(mStack.removeFirst(), mTupleS);
                }
            }
            mChildS.rewind();
            fillCache();
        }

        return null;
    }

    private void fillCache() throws TransactionAbortedException, DbException {
        int tuplecount = 0;
        mCache.clear();
        while (tuplecount < cacheLimit() && mChildR.hasNext()) {
            Tuple t = mChildR.next();
            Field f = t.getField(mChildR.field);
            List<Tuple> ts = mCache.get(f);
            if (ts == null) {
                ts = new ArrayList<Tuple>();
            }
            ts.add(t);
            mCache.put(f, ts);
            tuplecount++;
        }
    }

    private int cacheLimit() {
        return CACHE_SIZE / mChildR.getTupleDesc().getSize();
    }

    private JoinChild[] sortChildrenBySize(JoinChild c1, JoinChild c2) {
        JoinChild[] children = new JoinChild[2];

        if (c1.getTupleDesc().getSize() < c2.getTupleDesc().getSize()) {
            children[0] = c1;
            children[1] = c2;
        } else {
            children[0] = c2;
            children[1] = c1;
        }
        return children;
    }

    private Tuple concatTuples(Tuple t_r, Tuple t_s) {
        
        Tuple t1, t2;
        if (mChild1.getTupleDesc().getSize() < mChild2.getTupleDesc().getSize()) {
            t1 = t_r;
            t2 = t_s;
        } else {
            t1 = t_s;
            t2 = t_r;
        }

        Tuple t = new Tuple(getTupleDesc());
        int numFields1 = t1.getTupleDesc().numFields();
        int numFields2 = t2.getTupleDesc().numFields();

        for (int i = 0; i < numFields1; i++)
            t.setField(i, t1.getField(i));
        for (int i = 0; i < numFields2; i++)
            t.setField(i + numFields1, t2.getField(i));

        return t;
    }
}
